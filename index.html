<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Suspect Online (Firestore)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body { margin: 0; background: #0b1220; color: #e7ecff; }
    .wrap { max-width: 1020px; margin: 0 auto; padding: 14px; }
    .card { background:#121b2f; border:1px solid #223055; border-radius:14px; padding:14px; margin: 10px 0; }
    h1 { font-size: 20px; margin: 6px 0 10px; }
    h2 { font-size: 16px; margin: 0 0 10px; opacity:.95;}
    input, button, select {
      font-size: 16px; padding: 10px 12px; border-radius: 12px;
      border:1px solid #2a3c67; background:#0c1530; color:#e7ecff;
    }
    button { background:#2a55ff; border:none; cursor:pointer; }
    button.secondary { background:#223055; border:1px solid #2a3c67; }
    button.danger { background:#ff3b4d; }
    button.on { outline: 2px solid rgba(255,255,255,.35); }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .row { display:flex; gap:10px; flex-wrap: wrap; }
    .row > * { flex:1; min-width: 160px; }
    .pill { display:inline-block; padding: 6px 10px; border-radius: 999px; background:#0c1530; border:1px solid #2a3c67; margin: 4px 6px 0 0; font-size: 13px; }
    .muted { opacity:.75; }
    .tiny { font-size: 12px; opacity:.85; }
    .err { color:#ffb4b4; }

    .log {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 13px; white-space: pre-wrap;
      background:#0c1530; border:1px solid #2a3c67; border-radius:12px;
      padding:10px; max-height: 260px; overflow:auto;
    }

    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media (max-width:720px){ .grid2 { grid-template-columns: 1fr; } }

    /* Checklist */
    .checkGrid { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; }
    @media (max-width:900px){ .checkGrid { grid-template-columns: 1fr; } }

    .checkItem {
      display:flex; align-items:center; gap:10px;
      padding: 10px 12px; border-radius: 12px;
      background:#0c1530; border:1px solid #2a3c67;
      cursor:pointer; user-select:none;
      transition: transform .05s ease;
    }
    .checkItem:active { transform: scale(0.99); }

    .box {
      width:18px; height:18px; border-radius:6px;
      border:2px solid #6e86c9;
      flex: 0 0 auto;
      display:flex; align-items:center; justify-content:center;
      font-size: 13px;
    }
    .label { font-size: 15px; display:flex; gap:8px; align-items:center; }
    .emoji { width: 22px; text-align:center; }

    /* crossed (eliminado) */
    .checkItem.crossed { opacity: .55; }
    .checkItem.crossed .label { text-decoration: line-through; text-decoration-thickness: 2px; }
    .checkItem.crossed .box { background:#2a55ff; border-color:#2a55ff; }
    .checkItem.crossed .box::after { content:"‚úì"; color:white; font-weight:700; }

    /* possible (marcado como poss√≠vel) */
    .checkItem.possible { border-color: #ffd166; box-shadow: 0 0 0 2px rgba(255,209,102,.18) inset; }
    .checkItem.possible .box { border-color:#ffd166; }
    .possibleTag { margin-left:auto; font-size:12px; opacity:.9; padding:4px 8px; border-radius:999px; border:1px solid #ffd166; color:#ffd166; }

    /* Probabilities */
    .probGrid { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; }
    @media (max-width:900px){ .probGrid { grid-template-columns: 1fr; } }
    .probItem{
      display:flex; align-items:center; gap:10px;
      padding: 10px 12px; border-radius: 12px;
      background:#0c1530; border:1px solid #2a3c67;
    }
    .barWrap{ flex:1; }
    .barBg{ height:10px; border-radius:999px; background:#142248; border:1px solid #2a3c67; overflow:hidden; }
    .barFill{ height:100%; width:0%; background:#2a55ff; }
    .pct{ width:56px; text-align:right; font-variant-numeric: tabular-nums; }

    /* ===== Modal fullscreen para revelar 1 carta ===== */
    .modal { position: fixed; inset: 0; display: none; z-index: 9999; }
    .modal.open { display: block; }
    .modalBackdrop { position: absolute; inset:0; background: rgba(0,0,0,.65); }
    .modalSheet{
      position: absolute; left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      width: min(560px, calc(100vw - 24px));
      background:#0c1530; border:1px solid #2a3c67; border-radius: 16px;
      box-shadow: 0 10px 50px rgba(0,0,0,.45); overflow: hidden;
    }
    .modalHeader{
      display:flex; align-items:center; justify-content:space-between;
      padding: 12px 14px; background:#121b2f; border-bottom:1px solid #223055;
    }
    .modalTitle{ font-weight: 700; }
    .modalClose{
      width: 42px; height: 42px; border-radius: 12px;
      border:1px solid #2a3c67; background:#0c1530; color:#e7ecff;
      cursor:pointer;
    }
    .modalBody{ padding: 16px; }

    .bigCard{
      width: 100%; min-height: 160px;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      font-size: 28px; font-weight: 800; letter-spacing: .2px;
      padding: 20px; border-radius: 16px;
      background: radial-gradient(1200px 200px at 50% 0%, rgba(42,85,255,.35), transparent 60%), #0b1430;
      border: 1px solid #2a3c67; text-align:center;
    }
    .bigCard small{
      display:block; font-size: 14px; font-weight: 600; opacity:.8; margin-top: 10px;
    }

    /* Cartas clic√°veis na m√£o */
    .handBtn{ border:none; background:transparent; padding:0; margin:0; }
    .handBtn .pill{ cursor:pointer; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>üïµÔ∏è Suspect Online</h1>
      <div class="muted">Clue Suspect simplificado ‚Ä¢ Sala por c√≥digo ‚Ä¢ Firebase Firestore</div>
      <div class="tiny muted">‚úÖ Checklist + POSS√çVEL ‚Ä¢ ‚úÖ Modal ‚Äúmostrar 1 carta‚Äù ‚Ä¢ ‚úÖ Probabilidades opcionais (host antes de iniciar)</div>
    </div>

    <div class="card" id="authCard">
      <h2>1) Entrar</h2>
      <div class="row">
        <input id="playerName" placeholder="Seu nome (ex: Lucas)" />
        <button id="btnAnon">Entrar (an√¥nimo)</button>
      </div>
      <div class="tiny" id="uidLine"></div>
    </div>

    <div class="card" id="roomCard" style="display:none">
      <h2>2) Sala</h2>
      <div class="row">
        <input id="roomCode" placeholder="C√≥digo da sala (ex: AB12CD)" />
        <button id="btnCreate">Criar sala</button>
        <button id="btnJoin" class="secondary">Entrar na sala</button>
      </div>
      <div class="tiny muted">O host cria e compartilha o c√≥digo com os amigos.</div>
      <div class="tiny" id="roomStatus"></div>
      <div class="tiny err" id="errBox"></div>
    </div>

    <div class="card" id="gameCard" style="display:none">
      <h2>3) Jogo</h2>

      <div class="grid2">
        <div class="card" style="margin:0">
          <div><b>Sala:</b> <span id="roomLabel"></span></div>
          <div><b>Voc√™:</b> <span id="meLabel"></span> <span class="pill" id="hostPill" style="display:none">HOST</span></div>
          <div><b>Status:</b> <span id="phaseLabel" class="pill"></span></div>
          <div style="margin-top:10px" id="playersBox"></div>
        </div>

        <div class="card" style="margin:0">
          <div><b>Suas cartas</b> <span class="tiny muted">(toque em 1 carta para abrir em tela cheia)</span></div>
          <div id="handBox" style="margin-top:8px"></div>
        </div>
      </div>

      <!-- PROBABILIDADES (opcional pelo host) -->
      <div class="card" id="probCard" style="display:none">
        <h2>Probabilidades agora <span class="tiny muted">(ajudante ‚Äî baseado em pistas + suas elimina√ß√µes)</span></h2>
        <div class="probGrid">
          <div class="card" style="margin:0">
            <h2>Suspeitos</h2>
            <div id="probSus"></div>
          </div>
          <div class="card" style="margin:0">
            <h2>Objetos</h2>
            <div id="probObj"></div>
          </div>
          <div class="card" style="margin:0">
            <h2>Lugares</h2>
            <div id="probLoc"></div>
          </div>
        </div>
        <div class="tiny muted" style="margin-top:8px">
          Itens riscados/na sua m√£o viram 0%. Itens marcados como ‚ÄúPOSS√çVEL‚Äù ganham um empurr√£o (n√£o √© certeza).
        </div>
      </div>

      <!-- CHECKLIST -->
      <div class="card">
        <div class="row" style="align-items:center">
          <div style="flex:2; min-width:220px">
            <h2 style="margin:0">Checklist de dedu√ß√£o</h2>
            <div class="tiny muted">
              Modo atual:
              <span id="modeLabel" class="pill">RISCAR</span>
              ‚Ä¢ Toque em um item para aplicar o modo ‚Ä¢ Toque de novo para desfazer.
            </div>
          </div>
          <div style="flex:1; min-width:220px">
            <button id="btnModePossible" class="secondary" style="width:100%">Marcar como POSS√çVEL</button>
            <div class="tiny muted" style="margin-top:6px">Quando ativo, tocar marca/desmarca ‚ÄúPOSS√çVEL‚Äù.</div>
          </div>
          <div style="flex:1; min-width:180px">
            <button id="btnClearChecklist" class="secondary" style="width:100%">Limpar meu checklist</button>
          </div>
        </div>

        <div class="checkGrid" style="margin-top:10px">
          <div class="card" style="margin:0">
            <h2>Suspeitos</h2>
            <div id="checkSus"></div>
          </div>
          <div class="card" style="margin:0">
            <h2>Objetos</h2>
            <div id="checkObj"></div>
          </div>
          <div class="card" style="margin:0">
            <h2>Lugares</h2>
            <div id="checkLoc"></div>
          </div>
        </div>
      </div>

      <div class="card">
        <h2>A√ß√µes</h2>
        <div class="row">
          <button id="btnStart" class="secondary">Iniciar partida (host)</button>
          <button id="btnToggleProb" class="secondary" style="display:none">Probabilidades: DESLIGADO</button>
          <button id="btnDraw">Puxar pista</button>
          <button id="btnReset" class="danger">Encerrar sala</button>
        </div>

        <div class="grid2" style="margin-top:10px">
          <div class="card" style="margin:0">
            <h2>Palpite</h2>
            <select id="guessSus"></select>
            <select id="guessObj" style="margin-top:8px"></select>
            <select id="guessLoc" style="margin-top:8px"></select>
            <button id="btnGuess" style="margin-top:10px">Fazer palpite</button>
            <div class="tiny muted" style="margin-top:6px">
              (Vers√£o simples) O palpite vai pro log. A ‚Äúmostrada de carta‚Äù √© manual via popup da m√£o.
            </div>
          </div>

          <div class="card" style="margin:0">
            <h2>Acusa√ß√£o final</h2>
            <select id="accSus"></select>
            <select id="accObj" style="margin-top:8px"></select>
            <select id="accLoc" style="margin-top:8px"></select>
            <button id="btnAccuse" class="danger" style="margin-top:10px">Acusar</button>
            <div class="tiny muted" style="margin-top:6px">Se errar, voc√™ fica ‚Äúfora‚Äù (marcado no jogo).</div>
          </div>
        </div>
      </div>

      <div class="card">
        <h2>Pistas p√∫blicas</h2>
        <div id="publicClues"></div>
      </div>

      <div class="card">
        <h2>Log da sala</h2>
        <div class="log" id="logBox"></div>
      </div>
    </div>
  </div>

  <!-- MODAL: mostrar 1 carta em tela cheia -->
  <div id="cardModal" class="modal" aria-hidden="true">
    <div class="modalBackdrop" id="cardModalBackdrop"></div>
    <div class="modalSheet" role="dialog" aria-modal="true" aria-label="Carta revelada">
      <div class="modalHeader">
        <div class="modalTitle">Mostrando 1 carta</div>
        <button id="btnCloseCardModal" class="modalClose" aria-label="Fechar">‚úï</button>
      </div>
      <div class="modalBody">
        <div id="modalCardBig" class="bigCard"></div>
        <div class="tiny muted" style="margin-top:10px; text-align:center;">
          Dica: vire o celular e mostre s√≥ essa carta ao jogador ao lado.
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
    import {
      getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot,
      serverTimestamp, arrayUnion, deleteDoc
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

    // ================== FIREBASE CONFIG (SEU) ==================
    const firebaseConfig = {
      apiKey: "AIzaSyCIQ5Sonh7AVrmBCpEWr99V4UuyOH1gGyQ",
      authDomain: "clue-80365.firebaseapp.com",
      projectId: "clue-80365",
      storageBucket: "clue-80365.firebasestorage.app",
      messagingSenderId: "870296918956",
      appId: "1:870296918956:web:f8f9d95b44f8689af27809"
    };
    // ============================================================

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const fs = getFirestore(app);

    // ----- CARTAS + EMOJIS -----
    const SUSPECTS = [
      { name: "Alice", emoji: "üë©" },
      { name: "Bruno", emoji: "üë®" },
      { name: "Carla", emoji: "üë©‚Äçü¶±" },
      { name: "Diego", emoji: "üë®‚Äçü¶∞" },
      { name: "Elisa", emoji: "üë©‚Äçü¶≥" },
      { name: "F√°bio", emoji: "üë®‚Äçü¶±" }
    ];
    const OBJECTS = [
      { name: "Chave", emoji: "üîë" },
      { name: "Livro", emoji: "üìò" },
      { name: "Copo", emoji: "ü•õ" },
      { name: "Corda", emoji: "üßµ" },
      { name: "Tesoura", emoji: "‚úÇÔ∏è" },
      { name: "Lanterna", emoji: "üî¶" }
    ];
    const LOCATIONS = [
      { name: "Cozinha", emoji: "üç≥" },
      { name: "Sala", emoji: "üõãÔ∏è" },
      { name: "Quarto", emoji: "üõèÔ∏è" },
      { name: "Jardim", emoji: "üå≥" },
      { name: "Garagem", emoji: "üöó" },
      { name: "Escrit√≥rio", emoji: "üíº" }
    ];

    // Emoji label helpers
    const emojiSus = Object.fromEntries(SUSPECTS.map(x => [x.name, x.emoji]));
    const emojiObj = Object.fromEntries(OBJECTS.map(x => [x.name, x.emoji]));
    const emojiLoc = Object.fromEntries(LOCATIONS.map(x => [x.name, x.emoji]));
    const labelSus = (name) => `${emojiSus[name] || "üïµÔ∏è"} ${name}`;
    const labelObj = (name) => `${emojiObj[name] || "üß∞"} ${name}`;
    const labelLoc = (name) => `${emojiLoc[name] || "üìç"} ${name}`;

    // ---- 24 Clues (mistura de "hard" e "soft") ----
    const CLUE_TEMPLATES = [
      // 12 hard (sempre verdadeiras)
      { id:"H1", kind:"hard", text:"O culpado N√ÉO √© Alice.", ok:(m)=>m.suspect!=="Alice" },
      { id:"H2", kind:"hard", text:"O culpado N√ÉO √© Bruno.", ok:(m)=>m.suspect!=="Bruno" },
      { id:"H3", kind:"hard", text:"O culpado N√ÉO √© Carla.", ok:(m)=>m.suspect!=="Carla" },
      { id:"H4", kind:"hard", text:"O culpado N√ÉO √© Diego.", ok:(m)=>m.suspect!=="Diego" },
      { id:"H5", kind:"hard", text:"O culpado N√ÉO √© Elisa.", ok:(m)=>m.suspect!=="Elisa" },
      { id:"H6", kind:"hard", text:"O culpado N√ÉO √© F√°bio.", ok:(m)=>m.suspect!=="F√°bio" },
      { id:"H7", kind:"hard", text:"O objeto N√ÉO √© a Tesoura.", ok:(m)=>m.object!=="Tesoura" },
      { id:"H8", kind:"hard", text:"O objeto N√ÉO √© a Lanterna.", ok:(m)=>m.object!=="Lanterna" },
      { id:"H9", kind:"hard", text:"O objeto N√ÉO √© a Corda.", ok:(m)=>m.object!=="Corda" },
      { id:"H10", kind:"hard", text:"N√£o foi no Jardim.", ok:(m)=>m.location!=="Jardim" },
      { id:"H11", kind:"hard", text:"N√£o foi no Quarto.", ok:(m)=>m.location!=="Quarto" },
      { id:"H12", kind:"hard", text:"N√£o foi na Garagem.", ok:(m)=>m.location!=="Garagem" },

      // 12 soft (vagas)
      { id:"S1", kind:"soft", text:"Parece mais prov√°vel que o culpado seja uma mulher.", test:(m)=>["Alice","Carla","Elisa"].includes(m.suspect), weightTrue:0.70, weightFalse:0.30 },
      { id:"S2", kind:"soft", text:"Parece mais prov√°vel que o culpado seja um homem.", test:(m)=>["Bruno","Diego","F√°bio"].includes(m.suspect), weightTrue:0.70, weightFalse:0.30 },
      { id:"S3", kind:"soft", text:"H√° ind√≠cios de que o nome do culpado come√ßa com vogal.", test:(m)=>["Alice","Elisa"].includes(m.suspect), weightTrue:0.65, weightFalse:0.35 },
      { id:"S4", kind:"soft", text:"H√° ind√≠cios de que o nome do culpado come√ßa com consoante.", test:(m)=>["Bruno","Carla","Diego","F√°bio"].includes(m.suspect), weightTrue:0.65, weightFalse:0.35 },
      { id:"S5", kind:"soft", text:"√â mais prov√°vel que o objeto caiba na m√£o.", test:(m)=>["Chave","Livro","Copo","Lanterna"].includes(m.object), weightTrue:0.68, weightFalse:0.32 },
      { id:"S6", kind:"soft", text:"√â mais prov√°vel que o objeto N√ÉO seja cortante.", test:(m)=>m.object!=="Tesoura", weightTrue:0.70, weightFalse:0.30 },
      { id:"S7", kind:"soft", text:"H√° ind√≠cios de que o objeto N√ÉO √© usado para iluminar.", test:(m)=>m.object!=="Lanterna", weightTrue:0.70, weightFalse:0.30 },
      { id:"S8", kind:"soft", text:"H√° ind√≠cios de que o objeto N√ÉO tem ‚Äúfio/linha‚Äù.", test:(m)=>m.object!=="Corda", weightTrue:0.66, weightFalse:0.34 },
      { id:"S9", kind:"soft", text:"Parece mais prov√°vel que foi em um lugar dentro da casa.", test:(m)=>["Cozinha","Sala","Quarto","Escrit√≥rio"].includes(m.location), weightTrue:0.70, weightFalse:0.30 },
      { id:"S10", kind:"soft", text:"Parece mais prov√°vel que foi em um lugar externo.", test:(m)=>["Jardim","Garagem"].includes(m.location), weightTrue:0.70, weightFalse:0.30 },
      { id:"S11", kind:"soft", text:"H√° ind√≠cios de que foi em um ambiente com m√≥veis.", test:(m)=>["Sala","Quarto","Escrit√≥rio","Cozinha"].includes(m.location), weightTrue:0.65, weightFalse:0.35 },
      { id:"S12", kind:"soft", text:"H√° ind√≠cios de que foi perto de algo como uma ‚Äúmesa‚Äù.", test:(m)=>["Cozinha","Escrit√≥rio"].includes(m.location), weightTrue:0.66, weightFalse:0.34 },
    ];

    // ---------- helpers ----------
    const $ = (id) => document.getElementById(id);
    const safeUpper = (s) => (s||"").trim().toUpperCase().replace(/[^A-Z0-9]/g,"").slice(0,10);

    function shuffle(arr){
      const a=[...arr];
      for(let i=a.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [a[i],a[j]]=[a[j],a[i]];
      }
      return a;
    }
    function choice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
    function escapeHtml(s){
      return (s||"").replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
    }
    function randomRoomCode(){
      const chars="ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
      let out="";
      for(let i=0;i<6;i++) out += chars[Math.floor(Math.random()*chars.length)];
      return out;
    }
    function showErr(e){
      console.error(e);
      const msg = (e && (e.message || e.code)) ? `${e.code || ""} ${e.message || ""}`.trim() : String(e);
      $("errBox").textContent = "Erro: " + msg;
      alert("Erro:\n" + msg);
    }

    // ---------- state ----------
    let uid = null;
    let meName = "";
    let room = null;
    let isHost = false;
    let unsubRoom = null;

    // local cached for probabilities
    let lastHand = [];
    let lastPublicClues = [];

    // ============ CHECKLIST (LOCAL) ============
    let checklist = {
      crossed: { sus: new Set(), obj: new Set(), loc: new Set() },
      possible:{ sus: new Set(), obj: new Set(), loc: new Set() }
    };
    let checkMode = "cross";

    function checklistKey(){
      return `suspect_checklist_${room || "no_room"}_${uid || "no_uid"}`;
    }
    function saveChecklist(){
      const data = {
        crossed: {
          sus: Array.from(checklist.crossed.sus),
          obj: Array.from(checklist.crossed.obj),
          loc: Array.from(checklist.crossed.loc)
        },
        possible: {
          sus: Array.from(checklist.possible.sus),
          obj: Array.from(checklist.possible.obj),
          loc: Array.from(checklist.possible.loc)
        }
      };
      try { localStorage.setItem(checklistKey(), JSON.stringify(data)); } catch {}
    }
    function loadChecklist(){
      checklist = {
        crossed: { sus: new Set(), obj: new Set(), loc: new Set() },
        possible:{ sus: new Set(), obj: new Set(), loc: new Set() }
      };
      try{
        const raw = localStorage.getItem(checklistKey());
        if(!raw) return;
        const data = JSON.parse(raw);
        (data.crossed?.sus||[]).forEach(x=>checklist.crossed.sus.add(x));
        (data.crossed?.obj||[]).forEach(x=>checklist.crossed.obj.add(x));
        (data.crossed?.loc||[]).forEach(x=>checklist.crossed.loc.add(x));
        (data.possible?.sus||[]).forEach(x=>checklist.possible.sus.add(x));
        (data.possible?.obj||[]).forEach(x=>checklist.possible.obj.add(x));
        (data.possible?.loc||[]).forEach(x=>checklist.possible.loc.add(x));
      } catch {}
    }
    function setMode(mode){
      checkMode = mode;
      const btn = $("btnModePossible");
      const modeLabel = $("modeLabel");
      if(checkMode === "possible"){
        btn.classList.add("on");
        btn.textContent = "‚úÖ Modo POSS√çVEL (toque para voltar)";
        modeLabel.textContent = "POSS√çVEL";
      } else {
        btn.classList.remove("on");
        btn.textContent = "Marcar como POSS√çVEL";
        modeLabel.textContent = "RISCAR";
      }
    }
    function applyMode(group, value){
      const crossedSet = checklist.crossed[group];
      const possibleSet = checklist.possible[group];

      if(checkMode === "cross"){
        if(crossedSet.has(value)) crossedSet.delete(value);
        else { crossedSet.add(value); possibleSet.delete(value); }
      } else {
        if(possibleSet.has(value)) possibleSet.delete(value);
        else { possibleSet.add(value); crossedSet.delete(value); }
      }
      saveChecklist();
      renderChecklist();
      // recalcula se painel estiver ligado
      if($("probCard").style.display !== "none") updateProbabilities();
    }
    function clearChecklist(){
      checklist = {
        crossed: { sus: new Set(), obj: new Set(), loc: new Set() },
        possible:{ sus: new Set(), obj: new Set(), loc: new Set() }
      };
      saveChecklist();
      renderChecklist();
      if($("probCard").style.display !== "none") updateProbabilities();
    }
    function buildCheckItem(group, item){
      const value = item.name;
      const isCrossed = checklist.crossed[group].has(value);
      const isPossible = checklist.possible[group].has(value);

      const div = document.createElement("div");
      div.className = "checkItem" + (isCrossed ? " crossed" : "") + (isPossible ? " possible" : "");
      div.onclick = () => applyMode(group, value);

      const possibleTag = isPossible ? `<span class="possibleTag">POSS√çVEL</span>` : "";
      div.innerHTML = `
        <div class="box"></div>
        <div class="label">
          <span class="emoji">${escapeHtml(item.emoji)}</span>
          <span>${escapeHtml(item.name)}</span>
        </div>
        ${possibleTag}
      `;
      return div;
    }
    function renderChecklist(){
      $("checkSus").innerHTML = "";
      $("checkObj").innerHTML = "";
      $("checkLoc").innerHTML = "";
      SUSPECTS.forEach(it => $("checkSus").appendChild(buildCheckItem("sus", it)));
      OBJECTS.forEach(it => $("checkObj").appendChild(buildCheckItem("obj", it)));
      LOCATIONS.forEach(it => $("checkLoc").appendChild(buildCheckItem("loc", it)));
    }

    $("btnModePossible").onclick = () => setMode(checkMode === "possible" ? "cross" : "possible");
    $("btnClearChecklist").onclick = () => { if(confirm("Limpar seu checklist (s√≥ o seu)?")) clearChecklist(); };

    // ---------- Probabilities engine ----------
    const clueById = Object.fromEntries(CLUE_TEMPLATES.map(c => [c.id, c]));

    function allWorlds(){
      const worlds = [];
      for(const s of SUSPECTS) for(const o of OBJECTS) for(const l of LOCATIONS){
        worlds.push({ suspect:s.name, object:o.name, location:l.name });
      }
      return worlds;
    }

    function isEliminatedByMe(world){
      for(const c of lastHand){
        if(c.t==="sus" && c.n===world.suspect) return true;
        if(c.t==="obj" && c.n===world.object) return true;
        if(c.t==="loc" && c.n===world.location) return true;
      }
      if(checklist.crossed.sus.has(world.suspect)) return true;
      if(checklist.crossed.obj.has(world.object)) return true;
      if(checklist.crossed.loc.has(world.location)) return true;
      return false;
    }

    function possibleBoost(world){
      let mul = 1.0;
      if(checklist.possible.sus.has(world.suspect)) mul *= 1.25;
      if(checklist.possible.obj.has(world.object)) mul *= 1.25;
      if(checklist.possible.loc.has(world.location)) mul *= 1.25;
      return mul;
    }

    function weightFromClue(world, clueObj){
      const tpl = clueById[clueObj.id];
      if(!tpl) return 1;

      if(tpl.kind === "hard"){
        return tpl.ok(world) ? 1 : 0;
      } else {
        const t = tpl.test(world);
        return t ? (tpl.weightTrue ?? 0.7) : (tpl.weightFalse ?? 0.3);
      }
    }

    function computeMarginals(){
      const worlds = allWorlds();
      const weights = new Array(worlds.length).fill(1);

      for(let i=0;i<worlds.length;i++){
        if(isEliminatedByMe(worlds[i])) weights[i] = 0;
      }

      for(const clue of (lastPublicClues || [])){
        for(let i=0;i<worlds.length;i++){
          if(weights[i] === 0) continue;
          weights[i] *= weightFromClue(worlds[i], clue);
        }
      }

      for(let i=0;i<worlds.length;i++){
        if(weights[i] === 0) continue;
        weights[i] *= possibleBoost(worlds[i]);
      }

      const total = weights.reduce((a,b)=>a+b,0) || 1;

      const ps = Object.fromEntries(SUSPECTS.map(x=>[x.name,0]));
      const po = Object.fromEntries(OBJECTS.map(x=>[x.name,0]));
      const pl = Object.fromEntries(LOCATIONS.map(x=>[x.name,0]));

      for(let i=0;i<worlds.length;i++){
        const p = weights[i] / total;
        ps[worlds[i].suspect] += p;
        po[worlds[i].object]  += p;
        pl[worlds[i].location]+= p;
      }
      return { ps, po, pl };
    }

    function renderProbList(containerId, items, probs){
      const box = $(containerId);
      box.innerHTML = "";
      const sorted = [...items].map(it => ({
        name: it.name, emoji: it.emoji, p: probs[it.name] || 0
      })).sort((a,b)=>b.p-a.p);

      for(const it of sorted){
        const pct = Math.round(it.p * 1000)/10;
        const row = document.createElement("div");
        row.className = "probItem";
        row.innerHTML = `
          <div class="emoji">${escapeHtml(it.emoji)}</div>
          <div style="width:140px">${escapeHtml(it.name)}</div>
          <div class="barWrap">
            <div class="barBg"><div class="barFill" style="width:${pct}%;"></div></div>
          </div>
          <div class="pct">${pct.toFixed(1)}%</div>
        `;
        box.appendChild(row);
      }
    }

    function updateProbabilities(){
      if($("probCard").style.display === "none") return; // desligado
      const { ps, po, pl } = computeMarginals();
      renderProbList("probSus", SUSPECTS, ps);
      renderProbList("probObj", OBJECTS,  po);
      renderProbList("probLoc", LOCATIONS,pl);
    }

    // UI init select options (com emojis)
    function fillSelect(sel, arr, labelFn){
      sel.innerHTML = arr.map(x => `<option value="${escapeHtml(x.name)}">${escapeHtml(labelFn(x.name))}</option>`).join("");
    }
    fillSelect($("guessSus"), SUSPECTS, labelSus);
    fillSelect($("guessObj"), OBJECTS, labelObj);
    fillSelect($("guessLoc"), LOCATIONS, labelLoc);
    fillSelect($("accSus"), SUSPECTS, labelSus);
    fillSelect($("accObj"), OBJECTS, labelObj);
    fillSelect($("accLoc"), LOCATIONS, labelLoc);

    // ---------- Modal logic (mostrar 1 carta) ----------
    const modal = document.getElementById("cardModal");
    const modalBackdrop = document.getElementById("cardModalBackdrop");
    const btnCloseModal = document.getElementById("btnCloseCardModal");
    const modalCardBig = document.getElementById("modalCardBig");

    window.__showCardModal = (label, category) => {
      modalCardBig.innerHTML = `<div>${label}</div><small>${category}</small>`;
      modal.classList.add("open");
      modal.setAttribute("aria-hidden", "false");
      document.body.style.overflow = "hidden";
    };

    function closeCardModal(){
      modal.classList.remove("open");
      modal.setAttribute("aria-hidden", "true");
      document.body.style.overflow = "";
    }
    btnCloseModal.onclick = closeCardModal;
    modalBackdrop.onclick = closeCardModal;
    window.addEventListener("keydown", (e) => {
      if(e.key === "Escape" && modal.classList.contains("open")) closeCardModal();
    });

    // ---------- auth ----------
    $("btnAnon").onclick = async () => {
      try{
        meName = $("playerName").value.trim();
        if(!meName) return alert("Coloque seu nome üôÇ");
        await signInAnonymously(auth);
      } catch(e){ showErr(e); }
    };

    onAuthStateChanged(auth, (user) => {
      if(!user) return;
      uid = user.uid;
      $("uidLine").textContent = `Conectado ‚úÖ (uid: ${uid.slice(0,8)}‚Ä¶)`;
      $("roomCard").style.display = "";
      $("btnAnon").disabled = true;
      $("playerName").disabled = true;
    });

    // ---------- Firestore model ----------
    // rooms/{ROOM}
    //   hostId, phase, createdAt
    //   settings: { showProbabilities: boolean }
    //   players: { [uid]: { name, alive } }
    //   hands: { [uid]: [{t:"sus"|"obj"|"loc", n:"Nome"}] }
    //   clueDeck: [{id, kind, text}], clueIndex
    //   publicClues: [{id, kind, text, at}]
    //   log: [{text, at}]
    //   mystery: {suspect, object, location}  (‚ö†Ô∏è simples)

    function roomDocRef(code){ return doc(fs, "rooms", code); }

    // ---------- room ----------
    $("btnCreate").onclick = async () => {
      try{
        $("errBox").textContent = "";
        const code = safeUpper($("roomCode").value) || randomRoomCode();
        $("roomCode").value = code;
        await joinOrCreate(code, true);
      } catch(e){ showErr(e); }
    };

    $("btnJoin").onclick = async () => {
      try{
        $("errBox").textContent = "";
        const code = safeUpper($("roomCode").value);
        if(!code) return alert("Digite o c√≥digo da sala.");
        await joinOrCreate(code, false);
      } catch(e){ showErr(e); }
    };

    async function joinOrCreate(code, createIfMissing){
      room = code;
      const rref = roomDocRef(room);
      const snap = await getDoc(rref);

      if(!snap.exists()){
        if(!createIfMissing) return alert("Sala n√£o existe. Pe√ßa o c√≥digo certo ou crie uma nova.");
        await setDoc(rref, {
          createdAt: serverTimestamp(),
          hostId: uid,
          phase: "lobby",
          settings: { showProbabilities: false }, // ‚úÖ padr√£o
          players: {},
          hands: {},
          publicClues: [],
          log: []
        }, { merge: true });
        await pushLog(`Sala criada por ${meName}. C√≥digo: ${room}`);
      }

      await updateDoc(rref, { [`players.${uid}`]: { name: meName, alive: true } });

      // checklist local
      loadChecklist();
      setMode("cross");
      renderChecklist();

      // subscribe
      if(unsubRoom) unsubRoom();
      $("roomStatus").textContent = `Entrou na sala ${room}.`;
      $("roomLabel").textContent = room;
      $("meLabel").textContent = meName;

      $("gameCard").style.display = "";
      $("roomCard").style.display = "none";
      $("authCard").style.display = "none";

      unsubRoom = onSnapshot(rref, (docSnap) => {
        const data = docSnap.data();
        if(!data) return;

        isHost = data.hostId === uid;
        $("hostPill").style.display = isHost ? "inline-block" : "none";
        $("phaseLabel").textContent = data.phase || "lobby";

        // host-only actions
        $("btnStart").disabled = !isHost || (data.phase !== "lobby");
        $("btnReset").disabled = !isHost;

        // settings: showProbabilities (host controls only in lobby)
        const showProb = !!data.settings?.showProbabilities;
        $("probCard").style.display = showProb ? "" : "none";
        $("btnToggleProb").style.display = (isHost && data.phase === "lobby") ? "" : "none";
        $("btnToggleProb").textContent = "Probabilidades: " + (showProb ? "LIGADO" : "DESLIGADO");

        renderPlayers(data.players || {});

        lastHand = (data.hands && data.hands[uid]) ? data.hands[uid] : [];
        renderHand(lastHand);

        lastPublicClues = data.publicClues || [];
        renderPublicClues(lastPublicClues);

        renderLog(data.log || []);

        const meAlive = data.players?.[uid]?.alive !== false;
        $("btnDraw").disabled = data.phase !== "playing" || !meAlive;
        $("btnGuess").disabled = data.phase !== "playing" || !meAlive;
        $("btnAccuse").disabled = data.phase !== "playing" || !meAlive;

        if(showProb) updateProbabilities();
      });
    }

    $("btnToggleProb").onclick = async () => {
      try{
        if(!room || !isHost) return;
        const rref = roomDocRef(room);
        const snap = await getDoc(rref);
        const data = snap.data();
        if(!data) return;
        if(data.phase !== "lobby"){
          alert("S√≥ d√° pra ligar/desligar antes de iniciar a partida.");
          return;
        }
        const current = !!data.settings?.showProbabilities;
        await updateDoc(rref, { "settings.showProbabilities": !current });
      } catch(e){ showErr(e); }
    };

    function renderPlayers(players){
      const entries = Object.entries(players);
      if(entries.length === 0){
        $("playersBox").innerHTML = `<span class="muted">Sem jogadores.</span>`;
        return;
      }
      $("playersBox").innerHTML = entries.map(([id,p]) => {
        const alive = p.alive === false ? "‚ùå fora" : "‚úÖ";
        const you = id === uid ? " ‚Ä¢ voc√™" : "";
        return `<span class="pill">${alive} ${escapeHtml(p.name||"Jogador")}${you}</span>`;
      }).join(" ");
    }

    // ‚úÖ m√£o clic√°vel -> abre modal com 1 carta
    function renderHand(hand){
      if(!hand || hand.length===0){
        $("handBox").innerHTML = `<div class="muted">Ainda sem cartas (o host precisa iniciar).</div>`;
        return;
      }

      const pills = hand.map(c => {
        const label =
          c.t === "sus" ? labelSus(c.n) :
          c.t === "obj" ? labelObj(c.n) :
          labelLoc(c.n);

        const cat =
          c.t === "sus" ? "Suspeito" :
          c.t === "obj" ? "Objeto" :
          "Lugar";

        // IMPORTANTE: encode para n√£o quebrar aspas no onclick
        const safeLabel = encodeURIComponent(label);
        const safeCat = encodeURIComponent(cat);

        return `
          <button class="handBtn" type="button"
            onclick="window.__showCardModal(decodeURIComponent('${safeLabel}'), decodeURIComponent('${safeCat}'))">
            <span class="pill">${escapeHtml(label)}</span>
          </button>
        `;
      });

      $("handBox").innerHTML = pills.join(" ");
    }

    function renderPublicClues(clues){
      if(!clues || clues.length===0){
        $("publicClues").innerHTML = `<div class="muted">Nenhuma pista ainda.</div>`;
        return;
      }
      $("publicClues").innerHTML = clues.map(c => {
        const t = c.at?.seconds ? new Date(c.at.seconds*1000) : new Date(c.at || Date.now());
        const tag = c.kind === "hard" ? "‚úÖ CERTA" : "üå´Ô∏è VAGA";
        return `<div class="pill">${tag} ‚Ä¢ ${escapeHtml(c.text)} <span class="tiny muted">(${t.toLocaleTimeString()})</span></div>`;
      }).join("");
    }

    function renderLog(logArr){
      const items = [...(logArr||[])].sort((a,b)=>{
        const atA = a.at?.seconds ? a.at.seconds*1000 : (a.at||0);
        const atB = b.at?.seconds ? b.at.seconds*1000 : (b.at||0);
        return atA - atB;
      });
      $("logBox").textContent = items.map(i => {
        const t = i.at?.seconds ? new Date(i.at.seconds*1000) : new Date(i.at || Date.now());
        return `[${t.toLocaleTimeString()}] ${i.text}`;
      }).join("\n");
      $("logBox").scrollTop = $("logBox").scrollHeight;
    }

    async function pushLog(text){
      if(!room) return;
      const rref = roomDocRef(room);
      await updateDoc(rref, { log: arrayUnion({ text, at: new Date() }) });
    }

    // ---------- actions ----------
    $("btnStart").onclick = async () => {
      try{
        if(!room || !isHost) return;
        const rref = roomDocRef(room);
        const snap = await getDoc(rref);
        const data = snap.data();
        if(!data || data.phase !== "lobby") return;

        const playerIds = data.players ? Object.keys(data.players) : [];
        if(playerIds.length < 2) return alert("Entre com pelo menos 2 jogadores pra ficar legal üôÇ");

        const mystery = {
          suspect: choice(SUSPECTS).name,
          object: choice(OBJECTS).name,
          location: choice(LOCATIONS).name
        };

        // clue deck: hard true + all soft => 24
        const hardOk = CLUE_TEMPLATES.filter(c => c.kind==="hard" && c.ok(mystery));
        const softAll = CLUE_TEMPLATES.filter(c => c.kind==="soft");
        const clueDeck = shuffle([...hardOk, ...softAll]).slice(0, 24).map(c => ({
          id: c.id, kind: c.kind, text: c.text
        }));

        // Build deck as structured cards
        const allCards = [
          ...SUSPECTS.map(x => ({ t:"sus", n:x.name })),
          ...OBJECTS.map(x  => ({ t:"obj", n:x.name })),
          ...LOCATIONS.map(x=> ({ t:"loc", n:x.name }))
        ];
        const isMystery = (c) =>
          (c.t === "sus" && c.n === mystery.suspect) ||
          (c.t === "obj" && c.n === mystery.object) ||
          (c.t === "loc" && c.n === mystery.location);

        const deck = shuffle(allCards.filter(c => !isMystery(c)));

        // deal
        const hands = {};
        playerIds.forEach(pid => hands[pid] = []);
        let idx=0;
        for(const card of deck){
          const pid = playerIds[idx % playerIds.length];
          hands[pid].push(card);
          idx++;
        }

        await updateDoc(rref, {
          phase: "playing",
          mystery, // ‚ö†Ô∏è simples
          hands,
          clueDeck,
          clueIndex: 0,
          publicClues: [],
        });

        await pushLog(`üé¨ Partida iniciada! (Host: ${meName})`);
        await pushLog(`Objetivo: descobrir suspeito + objeto + lugar.`);
      } catch(e){ showErr(e); }
    };

    $("btnDraw").onclick = async () => {
      try{
        if(!room) return;
        const rref = roomDocRef(room);
        const snap = await getDoc(rref);
        const data = snap.data();
        if(!data || data.phase !== "playing") return;

        const idx = data.clueIndex || 0;
        const deck = data.clueDeck || [];
        if(idx >= deck.length) return alert("Acabaram as pistas!");

        const clue = deck[idx];
        await updateDoc(rref, {
          clueIndex: idx + 1,
          publicClues: arrayUnion({ ...clue, at: new Date() })
        });
        await pushLog(`üß© ${meName} puxou uma pista (${clue.kind === "hard" ? "certa" : "vaga"}): ${clue.text}`);
      } catch(e){ showErr(e); }
    };

    $("btnGuess").onclick = async () => {
      try{
        if(!room) return;
        const s = $("guessSus").value;
        const o = $("guessObj").value;
        const l = $("guessLoc").value;
        await pushLog(`‚ùì Palpite de ${meName}: ${labelSus(s)} + ${labelObj(o)} + ${labelLoc(l)}`);
      } catch(e){ showErr(e); }
    };

    $("btnAccuse").onclick = async () => {
      try{
        if(!room) return;
        const rref = roomDocRef(room);
        const snap = await getDoc(rref);
        const data = snap.data();
        if(!data || data.phase !== "playing") return;

        const s = $("accSus").value;
        const o = $("accObj").value;
        const l = $("accLoc").value;

        const ok =
          data.mystery?.suspect === s &&
          data.mystery?.object === o &&
          data.mystery?.location === l;

        if(ok){
          await pushLog(`üèÜ ${meName} ACUSOU e ACERTOU! Era ${labelSus(s)} com ${labelObj(o)} em ${labelLoc(l)}.`);
          await updateDoc(rref, { phase:"finished" });
          alert(`Voc√™ venceu! Era ${labelSus(s)} com ${labelObj(o)} em ${labelLoc(l)}.`);
        } else {
          await pushLog(`üí• ${meName} acusou e ERROU: ${labelSus(s)} + ${labelObj(o)} + ${labelLoc(l)}. (Ficou fora)`);
          await updateDoc(rref, { [`players.${uid}.alive`]: false });
          alert("Errou! Voc√™ ficou fora da disputa (mas pode continuar assistindo).");
        }
      } catch(e){ showErr(e); }
    };

    $("btnReset").onclick = async () => {
      try{
        if(!room || !isHost) return;
        const ok = confirm("Encerrar sala e apagar tudo? (todo mundo vai sair)");
        if(!ok) return;
        await deleteDoc(roomDocRef(room));
        location.reload();
      } catch(e){ showErr(e); }
    };
  </script>
</body>
</html>
